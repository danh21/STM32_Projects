/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"
#include "stdio.h"
//#include "stdlib.h"



void ADC_Start_IT();
uint32_t ReadADC();
uint32_t ADC_data;
float Voltage = 0;
double Degree = 0;



int _write(int file, char *ptr, int len) {
  for (int DataIdx = 0; DataIdx < len; DataIdx++)
    ITM_SendChar(*ptr++);
  return len;
}



void SysConfig()
{
	//enable HSI
	RCC->CR |= 1<<0;
	//RCC->CR |= RCC_CR_HSION;

	//see that HSI is ready or not
	while (!(RCC->CR & (1<<1)));
	//while(!(RCC->CR & RCC_CR_HSIRDY));

	//For channeling the power to APB1 bus
	RCC->APB1ENR |= 1<<3;										//Channelize to GPIO D PORT
	//RCC->APB1ENR |=RCC_AHB1ENR_GPIODEN;

	//Power regulator
	PWR->CR |= (1<<14);
	//PWR->CR |= PWR_CR_VOS;

	//Flash latency setup
	FLASH->ACR |= (1<<8) | (1<<10) | (1<<9) | (5<<0);
	//FLASH->ACR |= FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_5WS;

	//Clock configuration register for setting
	//RCC->CFGR |= RCC_CFGR_SW_HSI;
	RCC->CFGR |= (1<<0) | (1<<1);								// not allowed System clock switch

//	while ( (RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI );	// HSI oscillator used as system clock
	while ( !(RCC->CFGR & ~(1<<2)) & !(RCC->CFGR & ~(1<<3)) );
}



void GPIO_Init()
{
	RCC->AHB1ENR |= (1<<0);				//for port A

	GPIOA->MODER |= (1<<21) | (1<<19);
	//GPIOA->MODER |=(2<<20)|(2<<18);

	GPIOA->AFR[1] |= (7<<4) | (7<<8);	//Alternate function UART1 for pin A9, A10

	/*GPIOA->PUPDR|=(1<<20);
	GPIOA->OTYPER|=(1<<9);
	GPIOA->LCKR|=(1<<16)|(1<<10);//lock bit configuration A10 is read so 1,A9=0
	*/
}



void ADC_Init()
{
	RCC->APB2ENR |= (1<<8);		//ADC1 enable

	//ADC->CCR|=()//bit 17 and 16 set to 0 for prescaler to 2
	//ADC->CCR for same register bit 0 to 4 reset means all adc independent
	//ADC->CR1|=//Bits RES are 00 to select resolution to 12 bit in 15 clocks

	ADC1->CR1 |= (1<<5);		//Enable interrupt mode for EOC

	//ADC1->CR2|=(1<<1);
	ADC1->CR2 |= (1<<0);		//for continuous conversion and adc enable respectivily

	//ADC->SMPR1|=()//SMP18 or SMP16 set to 000 which means 3 sample cycles
	//ADC->DR data to read register
	//FOr monitoring purpose read only register
	//ADC->CSR:going to read bits (5->ADC1overrun), 4->ADC1RegularStartsuccess
	//ADC->CSR:read bit (1->End of conversion for ADC1)

	ADC1->CR2 |= (1<<30);		//start conversion of regular channels only with ADON=1

	//ALIGN in ADC->CR2 is 0 means right aligned
	//ADC->CR2 bit number 2 is EOC and this has to be with overrun
	//detection enable

	ADC->CCR |= (1<<23);		//Temperature sensor enable
	ADC1->CR2 |= (1<<0);		//ADON=1

	//ADC->CCR&=~((1<<16)|(1<<17));//bit 16,17=0 means prescaler is 2 ;same as 48L
	//ADC-CDR can be also used instead of DR
	//while(!(ADC1->SR & (1<<1)));//wait till end of conversion
}



void ADC_Start_Polling()
{
	ADC1->CR2 &= ~(1<<10);		// The EOC bit is set at the end of each sequence of regular conversions. Overrun detection is enabled only if DMA=1
	ADC1->SMPR1 |= (4<<18);		//84 clock cycle polling, 16th channel
	ADC1->CR2 |= (1<<30);		//start regular conversion
	while(!(ADC1->SR & (1<<4)));//wait until conversion starts
	//delay is by sampling time only not interrupt
	//sampling time may be adjusted by select 16th channel for temperature sensor
}



void ADC_End()
{
	ADC1->CR2 |= (1<<10); 		//bit is set at the end of each regular conversion.
}



void convercmpltcallback()
{
	ADC_data = ReadADC();		//will clear EOC
	printf("the value of ADC is %ld \n", ADC_data);
	for (int i=0; i<5000; i++);

	//printf();
	//in adc sr bit 4 to 0 resets flag
	//ADC_End();
	//ADC1->SR &=~(1<<4);//clearing EOC manually

	ADC_Start_IT();
}



void ADC_Start_IT()
{
	ADC1->CR2 |= (1<<30);			//start regular conversion
	ADC1->CR1 |= (1<<5);			//Enable interrupt mode for EOC

	while(!(ADC1->SR & (1<<4)));	//wait until conversion starts
	while(!(ADC1->SR & (1<<1)));	//wait for EOC to be set or end of conversion flag or conversion complete.

	//EOCIT ENABLE
	//where ever EOC flag is set==conversioncmplt
	if(ADC1->SR & (1<<1))
		convercmpltcallback();
}



uint32_t ReadADC()
{
	ADC_data = ADC1->DR;
	return ADC_data;
}
//go with practical data can have external sensor



void Send_byte(char c)
{
	USART1->DR = c;
	while(!(USART1->SR & (1<<6)));	// wait until Transmission complete
}



uint8_t Get_char()
{
	uint8_t data;
	while(!(USART1->SR & (1<<5)));	//  wait until Received data is ready to be read.
	data = USART1->DR;
	return data;
}



void UART_init()
{
	USART1->CR1 |= (1<<13) | (1<<3) | (1<<2);	// USART enable, Transmitter enable, Receiver enable
	USART1->CR1 |= (1<<15);						// oversampling by 8
	USART1->BRR |= (17<<4) | (3<<0);			// 17,3
}



int main(void)
{
   SysConfig();
   ADC_Init();
   GPIO_Init();
   UART_init();
   ADC_Start_IT();
   while(1)
   {
		//ADC_Start_Polling();
		//ADC_data=ReadADC();
		//Voltage=ADC_data*3.3/4095;
		//Degree=(Voltage*1000)/2.5;
		//printf("the value of ADC is %d \n",ADC_data);
		//printf("the value of ADC is\n");
		//printf("the value of ADC is %f 'C \n",Degree);
	   for(int i=0; i<1000; i++);
   }
   return 0;
}
